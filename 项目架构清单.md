# MRPC-2025-homework 项目架构清单

## 项目概述

本项目是中山大学移动机器人规划与控制课程的大作业,主要涉及四旋翼无人机的动力学建模、轨迹规划和控制。项目基于ROS (Robot Operating System) 开发,包含完整的仿真环境、建图系统、路径规划器和控制器。

**项目名称**: MRPC-2025-homework (Mobile Robot Planning and Control)
**开发语言**: C++, Python
**开发平台**: ROS (Ubuntu 20.04)
**许可证**: MIT License
**Git仓库**: git@github.com:Joker-of-Gotham/MRPC-2025-homework.git

---

## 目录结构

```
MRPC-2025-homework/
├── .git/                          # Git版本控制目录
├── .gitignore                     # Git忽略文件配置
├── check_completeness.sh          # 提交完整性检查脚本
├── README.md                      # 项目根目录说明文档
├── code/                          # 核心代码目录
│   ├── .catkin_workspace          # Catkin工作空间配置
│   ├── CMakeFiles/                # CMake编译文件
│   ├── calculate_results.py       # 结果评估脚本
│   ├── LICENSE                    # MIT许可证
│   ├── README.md                  # 代码部分说明文档
│   ├── assets/                    # 资源文件(图片)
│   │   ├── image-*.png           # 文档插图
│   │   └── wps*.jpg              # 文档插图
│   └── src/                       # ROS源代码目录
│       ├── map_server/            # 地图服务器模块
│       ├── quadrotor_simulator/   # 四旋翼仿真器模块
│       ├── trajectory_generator/  # 轨迹生成器模块
│       └── Utils/                 # 工具库模块
├── documents/                     # 作业文档目录
│   ├── homework.pdf               # 作业题目PDF
│   ├── tracking.csv               # 题目1:无人机姿态跟踪数据
│   └── solutions/                 # 文档题目参考解答
│       ├── q1_coordinate_transform.py  # 题目1:坐标系转换解答
│       ├── q1_quaternion_world.csv    # 题目1:计算结果CSV
│       └── q1_quaternion_world.png    # 题目1:四元数变化曲线图
└── solutions/                     # 学生提交目录
    └── result.txt                 # 任务三运行结果
```

---

## 根目录文件详解

### 1. README.md
**文件路径**: `/README.md`

**功能概述**: 项目根目录说明文档,包含作业评分细则、提交要求、助教联系方式等关键信息。

**主要内容**:
- **维护日志**: 记录项目重要更新日期和内容
  - 2025.11.22: 课程作业正式发布
  - 2025.11.25: 修正评价指标问题
  - 2025.12.02: 更新文档和修复bug
  - 2025.12.18: 删除测试移动步骤

- **统一评分细则**:
  - 完成题目1和题目2: 30分
  - 补全代码完成任务一: 30分
  - 任务二、任务三控制器调参: 1-40分
  - 附加题(任务四): 1-10分

- **作业要求**:
  - 必须使用Git进行版本管理
  - 所有代码必须独立完成,禁止抄袭
  - 运行check_completeness.sh检查提交完整性

- **提交方式**:
  - 压缩为"姓名-学号.zip"
  - 发送到指定邮箱
  - 包含report.pdf、video.mp4、result.txt等文件

---

### 2. .gitignore
**文件路径**: `/.gitignore`

**功能概述**: Git版本控制忽略文件配置,指定不需要纳入版本管理的文件和目录。

**忽略内容**:
```
.catkin_tools/
build/
devel/
logs/
.DS_Store/
.vscode/
```

**说明**:
- `catkin_tools/`: Catkin构建工具配置
- `build/`, `devel/`, `logs/`: ROS编译生成的中间文件
- `.DS_Store`: macOS系统文件
- `.vscode/`: VSCode编辑器配置

---

### 3. check_completeness.sh
**文件路径**: `/check_completeness.sh`

**功能概述**: 提交完整性检查脚本,用于验证学生提交的材料是否齐全。

**主要功能**:

1. **必需文件检查**:
   - `solutions/report.pdf` - 实验报告
   - `solutions/video.mp4` - 任务三飞行视频
   - `solutions/result.txt` - 任务三运行结果
   - `code/src/quadrotor_simulator/so3_control/src/issafe.txt` - 碰撞检测记录
   - `code/src/quadrotor_simulator/so3_control/src/control_timedata.txt` - 控制时间数据
   - `code/src/quadrotor_simulator/so3_control/src/control_data.txt` - 控制数据

2. **可选文件检查**:
   - `solutions/df_quaternion.csv` - 题目3选做结果
   - `code/src/quadrotor_df` - 题目3选做ROS包

3. **编译文件检查**:
   - 检查是否存在`devel/`, `build/`, `logs/`等编译生成的目录
   - 如果存在,提示学生在提交前删除

4. **空文件检查**:
   - 检查txt文件是否为空

**输出示例**:
```
【必需文件检查】
✓ solutions/report.pdf 存在
✓ solutions/video.mp4 存在
✓ solutions/result.txt 存在
...

【编译文件检查】
编译文件无需提交,请压缩之前先执行以下命令删除编译文件:
  rm -rf code/devel
  rm -rf code/build
  rm -rf code/logs
```

---

## code目录详解

### 一、code/README.md
**文件路径**: `code/README.md`

**功能概述**: 代码部分详细说明文档,包含环境安装、项目介绍、实验任务等内容。

**主要内容**:

#### 1. 统一评分细则与报告要求
- **代码部分评分**:
  - 补全代码并成功编译运行: 30分
  - 任务二、任务三完成并调好控制器: 1-40分
  - 附加题改进: 1-10分

- **报告要求**:
  - 贴出calculate_results.py的终端输出
  - 分析RMSE、轨迹运行时间、总长度、碰撞状态等指标
  - 如有附加题,说明改进思路和对比实验

#### 2. 运行环境安装
- **VMware安装**: 推荐VMware Workstation Pro 16
- **运行环境**: 已配置好的Ubuntu 20.04虚拟机(需预留30GB空间)
- **ROS基础知识**: 介绍ROS的Workspace、Package、Node结构

#### 3. 实验项目介绍
- **项目结构**:
  - `map_server`: 建图和规划
  - `quadrotor_simulator`: 仿真器
  - `trajectory_generator`: 轨迹规划
  - `Utils`: 工具库

- **信息传输流程**:
  ```
  /sim/imu → /visual_sim/odom → /random_complex → /pcl_render_node
  → /trajectory_generator_node → /traj_server → /so3_control
  → /quadrotor_simulator_so3
  ```

#### 4. 实验任务

**任务一: 补全四旋翼动力学模型**
- 文件: `Quadrotor.cpp`
- 需要补全:
  - 平动速度导数 `v_dot`
  - 角速度导数 `omega_dot`
- 测试步骤: 编译 → 测试悬停 → 验证效果

**任务二: 补全前端规划模块**
- 文件: `Astar_searcher.cpp`
- 需要补全:
  - STEP 1.1: 启发式函数 `getHeu()`
  - STEP 1.2: A*算法主循环
  - STEP 1.3: 路径追溯
- 测试步骤: 编译 → 启动仿真 → 测试路径规划

**任务三: 控制器参数调试**
- 文件: `so3_control_nodelet.cpp`
- 调参位置: `position_cmd_callback()` 函数中的 `kx_` 和 `kv_`
- 评估方法: 运行`calculate_results.py`获取RMSE等指标
- 提交: 录制video.mp4,生成result.txt

**任务四: 附加题(Optional)**
- 改进方向:
  1. 前端规划改进(JPS3D、Hybrid A*、RRT等)
  2. 后端轨迹优化改进
  3. 控制器改进(姿态环移植)

---

### 二、code/calculate_results.py
**文件路径**: `code/calculate_results.py`

**功能概述**: 轨迹跟踪效果评估脚本,计算RMSE、轨迹长度、碰撞状态等指标。

**主要功能**:

1. **路径解析**:
   ```python
   def _pick_best_run(base_dir, ros_dir):
       # 优先选择同一目录下的control_data、control_timedata、issafe
       # 按修改时间排序,选择最新的control_data
   ```

2. **读取数据**:
   - 读取`control_data.txt`: 期望位置和实际位置
   - 读取`control_timedata.txt`: 时间戳数据
   - 读取`issafe.txt`: 碰撞检测记录

3. **计算指标**:
   - **RMSE**: 均方根误差
     ```python
     rmse = sqrt(mean(desired_pos - actual_pos)^2)
     ```
   - **Total Time**: 轨迹运行总时间
     ```python
     # 使用control_timedata计算,避免跨文件相减
     total_time = last_timestamp - first_timestamp
     ```
   - **Total Length**: 轨迹总长度
     ```python
     total_length = sum(相邻点距离)
     ```
   - **Collision**: 是否发生碰撞
     ```python
     # issafe.txt非空则碰撞
     collision = 1 if issafe_txt else 0
     ```
   - **Overall Score**: 综合得分(越低越好)
     ```python
     score = 200 * RMSE + 0.2 * time + 0.2 * length + 40 * collision
     ```

4. **输出结果**:
   - 终端输出: 打印所有指标
   - 文件保存: 保存到`solutions/result.txt`

**使用方法**:
```bash
cd MRPC-2025-homework/
python3 calculate_results.py
```

**输出示例**:
```
计算得到的均方根误差(RMSE)值为: 0.11586971639650995
轨迹运行总时间为: 47.12802791595459
总轨迹长度为: 33.97356465040666
是否发生了碰撞: 1
综合评价得分为(综合分数越低越好): 1.3102676466588432
```

---

### 三、code/LICENSE
**文件路径**: `code/LICENSE`

**功能概述**: MIT开源许可证,声明版权和使用条款。

**主要内容**:
- 版权所有: SYSU HILAB (2024)
- 授权范围: 免费、无限制使用、修改、分发
- 限制条件: 必须包含版权声明和许可证文本
- 免责声明: 软件按"原样"提供,不提供任何担保

---

## code/src 目录详解

### 一、map_server 模块

#### 1. map_generator 包

**包路径**: `code/src/map_server/map_generator/`

**功能概述**: 生成随机复杂地图,包含障碍物和地面。

##### 文件: random_complex_generator.cpp
**文件路径**: `code/src/map_server/map_generator/src/random_complex_generator.cpp`

**主要功能**: 生成随机复杂3D地图,包含圆柱形障碍物和地面。

**关键参数**:
- `_obs_num`: 障碍物数量(默认30)
- `_cir_num`: 圆形障碍物数量(默认30)
- `_x_size`, `_y_size`, `_z_size`: 地图尺寸(默认50x50x5米)
- `_resolution`: 地图分辨率(默认0.2米)
- `_w_l`, `_w_h`: 障碍物宽度范围(0.3-0.8米)
- `_h_l`, `_h_h`: 障碍物高度范围(3.0-7.0米)

**主要函数**:

1. **RandomMapGenerate(bool ground_map_swt)**
   - 生成随机地图
   - 如果`ground_map_swt=true`: 生成障碍物地图
   - 如果`ground_map_swt=false`: 生成地面地图

2. **FixedMapGenerate()**
   - 生成固定地图(仅地面)

3. **地图生成流程**:
   ```cpp
   // 1. 使用固定种子随机数生成器
   const int FIXED_SEED = 12346;
   default_random_engine eng(FIXED_SEED);

   // 2. 生成圆形障碍物
   for (int i = 0; i < _cir_num; i++) {
       // 随机中心位置、半径、旋转角度
       x0 = rand_x_circle(eng);
       y0 = rand_y_circle(eng);
       z0 = rand_h(eng) / 2.0;
       R = rand_r_circle(eng);

       // 生成椭圆并旋转
       for (double theta = -M_PI; theta < M_PI; theta += 0.025) {
           // 椭圆方程
           x = a * cos(theta) * R;
           y = b * sin(theta) * R;
           // 应用3D旋转矩阵
           pt3_rot = Rot * pt3;
           cloudMap.points.push_back(pt_rot);
       }
   }

   // 3. 生成柱状障碍物
   for (int i = 0; i < _obs_num + 1; i++) {
       // 使用KD树检查距离,避免障碍物重叠
       if (kdtreeMap.nearestKSearch(searchPoint, 1, ...) > 0) {
           if (sqrt(pointSquaredDistance[0]) < 1.0)
               continue;  // 距离太近,跳过
       }
       // 生成柱状障碍物
       for (int t = 0; t < heiNum; t++) {
           pt_random.z = (t + 0.0) * _resolution * 0.5 + 0.001;
           cloudMap.points.push_back(pt_random);
       }
   }
   ```

4. **发布话题**:
   - `/random_complex/global_map`: 全局障碍物地图
   - `/random_complex/global_ground`: 全局地面地图

**配置参数** (launch文件):
```yaml
map:
  x_size: 50.0
  y_size: 50.0
  z_size: 5.0
  obs_num: 30
  circle_num: 30
  resolution: 0.2

ObstacleShape:
  lower_rad: 0.3
  upper_rad: 0.8
  lower_hei: 3.0
  upper_hei: 7.0

CircleShape:
  lower_circle_rad: 0.3
  upper_circle_rad: 0.8

sensing:
  rate: 1.0
```

---

#### 2. map_render 包

**包路径**: `code/src/map_server/map_render/`

**功能概述**: 将全局地图渲染为点云,并根据无人机位置发布局部感知范围内的点云。

##### 文件: pcl_render_node.cpp
**文件路径**: `code/src/map_server/map_render/src/pcl_render_node.cpp`

**主要功能**: 接收全局地图,根据无人机位置计算局部感知范围内的点云并发布。

**关键参数**:
- `sensing_horizon`: 感知半径(默认10米)
- `sensing_rate`: 感知频率(默认1.0 Hz)
- `estimation_rate`: 估计频率
- `_x_size`, `_y_size`, `_z_size`: 地图尺寸
- `_resolution`: 地图分辨率

**主要函数**:

1. **rcvGlobalPointCloudCallBack()**
   - 接收全局障碍物地图
   - 使用VoxelGrid下采样(0.1米)
   - 构建KD树用于快速查询

2. **rcvGlobalGroundPointCloudCallBack()**
   - 接收全局地面地图
   - 合并到全局点云

3. **renderSensedPoints(const ros::TimerEvent &event)**
   - 根据无人机位置计算局部感知范围
   - 使用KD树半径搜索获取感知范围内的点
   - 应用视野限制(前向视角)
   - 应用高度限制(±15度)

   ```cpp
   // 1. 获取无人机位置和姿态
   Eigen::Quaterniond q;
   q.x() = _odom.pose.pose.orientation.x;
   q.y() = _odom.pose.pose.orientation.y;
   q.z() = _odom.pose.pose.orientation.z;
   q.w() = _odom.pose.pose.orientation.w;
   Eigen::Matrix3d rot = q;
   Eigen::Vector3d yaw_vec = rot.col(0);  // 前向向量

   // 2. KD树半径搜索
   pcl::PointXYZ searchPoint(_odom.pose.pose.position.x,
                             _odom.pose.pose.position.y,
                             _odom.pose.pose.position.z);
   _kdtreeLocalMap.radiusSearch(searchPoint, sensing_horizon,
                                 _pointIdxRadiusSearch, _pointRadiusSquaredDistance);

   // 3. 视野和高度限制
   for (size_t i = 0; i < _pointIdxRadiusSearch.size(); ++i) {
       pt = _cloud_all_map.points[_pointIdxRadiusSearch[i]];

       // 高度限制: ±15度
       if ((fabs(pt.z - _odom.pose.pose.position.z) / sensing_horizon) > tan(M_PI / 12.0))
           continue;

       // 前向视角限制
       Vector3d pt_vec(pt.x - _odom.pose.pose.position.x,
                       pt.y - _odom.pose.pose.position.y,
                       pt.z - _odom.pose.pose.position.z);
       if (pt_vec.dot(yaw_vec) < 0)
           continue;  // 在后方,跳过

       _local_map.points.push_back(pt);
   }
   ```

4. **发布话题**:
   - `/local_pointcloud`: 局部感知点云
   - `/global_map_vis`: 全局地图可视化
   - `/global_ground_vis`: 全局地面可视化

**订阅话题**:
- `/global_map`: 全局障碍物地图
- `/global_ground`: 全局地面地图
- `/odometry`: 无人机里程计

---

### 二、quadrotor_simulator 模块

#### 1. so3_control 包

**包路径**: `code/src/quadrotor_simulator/so3_control/`

**功能概述**: SO3位置和速度控制器,接收位置指令并输出SO3控制指令(推力和姿态)。

##### 文件: so3_control_nodelet.cpp
**文件路径**: `code/src/quadrotor_simulator/so3_control/src/so3_control_nodelet.cpp`

**主要功能**: SO3控制器节点,接收位置指令,计算期望推力和姿态。

**关键类**: `SO3ControlNodelet`

**主要函数**:

1. **position_cmd_callback()**
   - 接收位置指令
   - **任务三调参位置**: 设置`kx_`和`kv_`参数
   - 记录时间戳
   - 发布SO3控制指令

   ```cpp
   void SO3ControlNodelet::position_cmd_callback(
       const quadrotor_msgs::PositionCommand::ConstPtr& cmd)
   {
       // 提取期望位置、速度、加速度
       des_pos_ = Eigen::Vector3d(cmd->position.x, cmd->position.y, cmd->position.z);
       des_vel_ = Eigen::Vector3d(cmd->velocity.x, cmd->velocity.y, cmd->velocity.z);
       des_acc_ = Eigen::Vector3d(cmd->acceleration.x, cmd->acceleration.y,
                                  cmd->acceleration.z);

       // ========== 任务三: 调参位置 ==========
       // 建议参数:
       // XY方向: kx = 15.7, kv = 6.4
       // Z方向:  kx = 6.0,  kv = 4.0
       kx_ = Eigen::Vector3d(15.7, 8.7, 6.0);
       kv_ = Eigen::Vector3d(6.4, 13.4, 4.0);

       des_yaw_ = cmd->yaw;
       des_yaw_dot_ = cmd->yaw_dot;

       appendTimedata_(ros::Time::now().toSec());  // 记录时间戳

       publishSO3Command();
   }
   ```

2. **odom_callback()**
   - 接收里程计数据
   - 更新位置、速度、姿态

3. **publishSO3Command()**
   - 调用`SO3Control::calculateControl()`计算控制输出
   - 发布SO3控制指令

4. **appendTimedata_(double t)**
   - 记录时间戳到`control_timedata.txt`
   - 用于计算轨迹运行总时间

**发布话题**:
- `/so3_cmd`: SO3控制指令(推力和姿态)

**订阅话题**:
- `/position_cmd`: 位置指令
- `/odometry`: 里程计

**配置文件** (`config/gains.yaml`):
```yaml
mass: 0.98
g: 9.81
max_F: 40.0  # 最大推力
```

---

##### 文件: SO3Control.cpp
**文件路径**: `code/src/quadrotor_simulator/so3_control/src/SO3Control.cpp`

**主要功能**: SO3控制器核心计算,根据位置误差和速度误差计算期望推力和姿态。

**关键类**: `SO3Control`

**主要函数**:

1. **calculateControl()**
   - 计算位置/速度误差
   - PD控制 + 重力补偿
   - 构造期望姿态

   ```cpp
   void SO3Control::calculateControl(
       const Eigen::Vector3d& des_pos, const Eigen::Vector3d& des_vel,
       const Eigen::Vector3d& des_acc, double des_yaw, double des_yaw_dot,
       const Eigen::Vector3d& kx, const Eigen::Vector3d& kv)
   {
       // 1. 计算误差
       const Eigen::Vector3d e_p = des_pos - pos_;
       const Eigen::Vector3d e_v = des_vel - vel_;

       // 2. PD控制 + 重力补偿
       Eigen::Vector3d a_cmd =
           des_acc +
           kx.asDiagonal() * e_p +      // 位置误差项
           kv.asDiagonal() * e_v +      // 速度误差项
           g_ * Eigen::Vector3d(0.0, 0.0, 1.0);  // 重力补偿

       // 3. 计算世界系合力
       force_ = mass_ * a_cmd;

       // 4. 构造期望姿态
       // b3对齐a_cmd方向
       Eigen::Vector3d b3c = a_cmd.normalized();

       // b1对齐des_yaw方向
       const double cy = std::cos(des_yaw);
       const double sy = std::sin(des_yaw);
       Eigen::Vector3d b1d(cy, sy, 0.0);

       // b2 = b3 x b1
       Eigen::Vector3d b2c = b3c.cross(b1d).normalized();

       // b1 = b2 x b3
       Eigen::Vector3d b1c = b2c.cross(b3c).normalized();

       // 构造旋转矩阵
       Eigen::Matrix3d R;
       R.col(0) = b1c;
       R.col(1) = b2c;
       R.col(2) = b3c;

       // 转换为四元数
       orientation_ = Eigen::Quaterniond(R);
   }
   ```

2. **getComputedForce()**
   - 返回计算得到的推力

3. **getComputedOrientation()**
   - 返回计算得到的姿态四元数

**控制原理**:
- 位置环: PD控制
- 姿态环: 根据期望推力方向构造姿态
- 重力补偿: 直接补偿重力加速度

---

##### 文件: SO3Control.h
**文件路径**: `code/src/quadrotor_simulator/so3_control/include/so3_control/SO3Control.h`

**主要功能**: SO3控制器类定义。

**关键成员变量**:
```cpp
Eigen::Vector3d pos_;          // 位置
Eigen::Vector3d vel_;          // 速度
Eigen::Vector3d des_pos_;      // 期望位置
Eigen::Vector3d des_vel_;      // 期望速度
Eigen::Vector3d des_acc_;      // 期望加速度
Eigen::Vector3d kx_, kv_;      // PD增益
double mass_;                  // 质量
double g_;                     // 重力加速度
Eigen::Vector3d force_;        // 计算得到的推力
Eigen::Quaterniond orientation_;  // 计算得到的姿态
```

**关键方法**:
```cpp
void calculateControl(...);              // 计算控制输出
Eigen::Vector3d getComputedForce();      // 获取推力
Eigen::Quaterniond getComputedOrientation();  // 获取姿态
```

---

#### 2. so3_quadrotor_simulator 包

**包路径**: `code/src/quadrotor_simulator/so3_quadrotor_simulator/`

**功能概述**: 四旋翼动力学仿真器,包含姿态控制和刚体动力学。

##### 文件: dynamics/Quadrotor.cpp
**文件路径**: `code/src/quadrotor_simulator/so3_quadrotor_simulator/src/dynamics/Quadrotor.cpp`

**主要功能**: 四旋翼刚体动力学模型,**任务一补全位置**。

**关键类**: `Quadrotor`

**主要函数**:

1. **operator()**
   - 动力学微分方程(ODE)
   - **任务一需要补全**: `v_dot`和`omega_dot`

   ```cpp
   void Quadrotor::operator()(const Quadrotor::InternalState& x,
                               Quadrotor::InternalState& dxdt, const double /* t */)
   {
       // 提取状态
       cur_state.x = x.segment<3>(0);      // 位置
       cur_state.v = x.segment<3>(3);      // 速度
       cur_state.R = Map<Matrix3d>(x.segment<9>(6).data());  // 姿态矩阵
       cur_state.omega = x.segment<3>(15); // 角速度

       // ========== 任务一: 补全动力学模型 ==========

       // 1) 平动: x_dot, v_dot
       x_dot = cur_state.v;

       // v_dot = (重力 + 总推力 + 外力 + 空气阻力) / 质量
       const Eigen::Vector3d gravity(0.0, 0.0, -g_);
       const Eigen::Vector3d thrust_world = R * Eigen::Vector3d(0.0, 0.0, thrust);
       const Eigen::Vector3d drag_world = -resistance * vnorm;

       v_dot = gravity + (thrust_world + external_force_ + drag_world) / mass_;
       acc_ = v_dot;

       // 2) 姿态: R_dot
       R_dot = R * omega_vee;

       // 3) 转动: omega_dot (欧拉方程)
       // omega_dot = J^(-1) * (力矩 - 科里奥利力 + 外部力矩 + 阻尼)
       const Eigen::Vector3d coriolis = cur_state.omega.cross(J_ * cur_state.omega);
       const double k_omega = 1e-3;  // 转动阻尼
       const Eigen::Vector3d tau_damp = -k_omega * cur_state.omega;

       omega_dot = J_.inverse() * (moments - coriolis + external_moment_ + tau_damp);
   }
   ```

2. **step()**
   - 数值积分更新状态
   - 使用RK4或Euler方法

**模型参数**:
```cpp
mass_ = 0.98;                          // 质量 (kg)
g_ = 9.81;                             // 重力加速度 (m/s^2)
kf_ = 8.98132e-9;                      // 推力系数
km_ = 0.07 * 3 * prop_radius_ * kf_;   // 力矩系数
arm_length_ = 0.26;                    // 臂长 (m)
prop_radius_ = 0.062;                  // 螺旋桨半径 (m)

// 惯性矩 (kg·m^2)
Ixx = 2.64e-3;
Iyy = 2.64e-3;
Izz = 4.96e-3;
```

**状态变量**:
```cpp
struct InternalState {
    Eigen::Matrix<double, 18, 1> data;
    // [0:2]   - 位置 (x, y, z)
    // [3:5]   - 速度 (vx, vy, vz)
    // [6:14]  - 姿态矩阵 (R, 3x3)
    // [15:17] - 角速度 (wx, wy, wz)
};
```

---

##### 文件: quadrotor_simulator_so3.cpp
**文件路径**: `code/src/quadrotor_simulator/so3_quadrotor_simulator/src/quadrotor_simulator_so3.cpp`

**主要功能**: 四旋翼仿真主程序,包含姿态控制和动力学仿真。

**主要函数**:

1. **getControl()**
   - 根据SO3指令计算电机转速
   - 姿态控制律

   ```cpp
   static Control getControl(const QuadrotorSimulator::Quadrotor& quad,
                            const Command& cmd)
   {
       // 1. 提取当前姿态和角速度
       float R11 = R(0, 0), R12 = R(0, 1), R13 = R(0, 2);
       float R21 = R(1, 0), R22 = R(1, 1), R23 = R(1, 2);
       float R31 = R(2, 0), R32 = R(2, 1), R33 = R(2, 2);
       float Om1 = omega(0), Om2 = omega(1), Om3 = omega(2);

       // 2. 提取期望姿态
       float Rd11 = Rd(0, 0), Rd12 = Rd(0, 1), Rd13 = Rd(0, 2);
       float Rd21 = Rd(1, 0), Rd22 = Rd(1, 1), Rd23 = Rd(1, 2);
       float Rd31 = Rd(2, 0), Rd32 = Rd(2, 1), Rd33 = Rd(2, 2);

       // 3. 计算姿态误差 (SO3李代数)
       float eR1 = 0.5f * (R12 * Rd13 - R13 * Rd12 +
                          R22 * Rd23 - R23 * Rd22 +
                          R32 * Rd33 - R33 * Rd32);
       float eR2 = 0.5f * (R13 * Rd11 - R11 * Rd13 -
                          R21 * Rd23 + R23 * Rd21 -
                          R31 * Rd33 + R33 * Rd31);
       float eR3 = 0.5f * (R11 * Rd12 - R12 * Rd11 +
                          R21 * Rd22 - R22 * Rd21 +
                          R31 * Rd32 - R32 * Rd31);

       // 4. 计算角速度误差
       float eOm1 = Om1, eOm2 = Om2, eOm3 = Om3;

       // 5. 计算科里奥利力矩
       float in1 = Om2 * (I[2][0]*Om1 + I[2][1]*Om2 + I[2][2]*Om3) -
                   Om3 * (I[1][0]*Om1 + I[1][1]*Om2 + I[1][2]*Om3);
       float in2 = Om3 * (I[0][0]*Om1 + I[0][1]*Om2 + I[0][2]*Om3) -
                   Om1 * (I[2][0]*Om1 + I[2][1]*Om2 + I[2][2]*Om3);
       float in3 = Om1 * (I[1][0]*Om1 + I[1][1]*Om2 + I[1][2]*Om3) -
                   Om2 * (I[0][0]*Om1 + I[0][1]*Om2 + I[0][2]*Om3);

       // 6. 计算期望力矩 (PD控制)
       float M1 = -cmd.kR[0] * eR1 - cmd.kOm[0] * eOm1 + in1;
       float M2 = -cmd.kR[1] * eR2 - cmd.kOm[1] * eOm2 + in2;
       float M3 = -cmd.kR[2] * eR3 - cmd.kOm[2] * eOm3 + in3;

       // 7. 分配到四个电机
       // w_sq[0]: 前左, w_sq[1]: 前右, w_sq[2]: 后右, w_sq[3]: 后左
       w_sq[0] = force / (4 * kf) - M2 / (2 * d * kf) + M3 / (4 * km);
       w_sq[1] = force / (4 * kf) + M2 / (2 * d * kf) + M3 / (4 * km);
       w_sq[2] = force / (4 * kf) + M1 / (2 * d * kf) - M3 / (4 * km);
       w_sq[3] = force / (4 * kf) - M1 / (2 * d * kf) - M3 / (4 * km);

       return Control(w_sq);
   }
   ```

2. **stateToOdomMsg()**
   - 将状态转换为ROS里程计消息

3. **quadToImuMsg()**
   - 将状态转换为IMU消息

**姿态控制律**:
- 姿态误差: SO3李代数 `eR = 0.5 * (R * Rd^T - Rd * R^T)`
- 角速度误差: `eOmega = omega - Rd * omega_d`
- 期望力矩: `M = -kR * eR - kOmega * eOmega + omega x (J * omega)`

**电机分配**:
```
        M2
         ^
         |
    M3 ---+--- M1
         |
         v
        M4
```

---

##### 文件: include/quadrotor_simulator/Quadrotor.h
**文件路径**: `code/src/quadrotor_simulator/so3_quadrotor_simulator/include/quadrotor_simulator/Quadrotor.h`

**主要功能**: 四旋翼类定义。

**关键结构体**:
```cpp
struct State {
    Eigen::Vector3d x;          // 位置 (m)
    Eigen::Vector3d v;          // 速度 (m/s)
    Eigen::Matrix3d R;          // 姿态矩阵
    Eigen::Vector3d omega;      // 角速度 (rad/s)
    Eigen::Array4d  motor_rpm;  // 电机转速 (rpm)
};
```

**关键成员变量**:
```cpp
double mass_;                    // 质量
Eigen::Matrix3d J_;             // 惯性矩矩阵
double g_;                       // 重力加速度
double kf_;                      // 推力系数
double km_;                      // 力矩系数
double arm_length_;              // 臂长
double prop_radius_;             // 螺旋桨半径
double resistance_;              // 空气阻力系数
```

**关键方法**:
```cpp
void operator()(const InternalState& x, InternalState& dxdt, double t);  // 动力学方程
State getState() const;        // 获取当前状态
void setState(const State& s); // 设置状态
void step(double dt, const Input& u);  // 数值积分
```

---

### 三、trajectory_generator 模块

**包路径**: `code/src/trajectory_generator/`

**功能概述**: 轨迹生成模块,负责前端路径搜索(A*)和后端轨迹优化(最小jerk多项式)。

#### 文件: trajectory_generator_node.cpp
**文件路径**: `code/src/trajectory_generator/src/trajectory_generator_node.cpp`

**主要功能**: 轨迹生成主节点,实现状态机管理和轨迹发布。

**关键类**: `TrajectoryGeneratorNode`

**状态机**:
```cpp
enum EXEC_STATE {
    INIT,           // 初始化
    WAIT_TARGET,    // 等待目标点
    GEN_NEW_TRAJ,   // 生成新轨迹
    EXEC_TRAJ,      // 执行轨迹
    REPLAN_TRAJ,    // 重新规划
    EMER_STOP       // 紧急停止
};
```

**主要函数**:

1. **execCallback()**
   - 状态机主循环
   - 根据当前状态执行相应操作

   ```cpp
   void TrajectoryGeneratorNode::execCallback(const ros::TimerEvent& e)
   {
       static int exec_num = 0;
       exec_num++;

       switch (exec_state_) {
           case INIT:
               // 初始化状态
               if (!has_odom_) {
                   ROS_WARN("Waiting for odometry...");
                   return;
               }
               if (!has_map_) {
                   ROS_WARN("Waiting for map...");
                   return;
               }
               exec_state_ = WAIT_TARGET;
               ROS_INFO("[TrajGenerator]: Waiting for target.");
               break;

           case WAIT_TARGET:
               // 等待目标点
               if (has_target_) {
                   exec_state_ = GEN_NEW_TRAJ;
                   ROS_INFO("[TrajGenerator]: Get target, start planning.");
               }
               break;

           case GEN_NEW_TRAJ:
               // 生成新轨迹
               trajGeneration();
               if (traj_success_) {
                   exec_state_ = EXEC_TRAJ;
                   traj_start_time_ = ros::Time::now();
                   ROS_INFO("[TrajGenerator]: Trajectory generated, start executing.");
               } else {
                   exec_state_ = WAIT_TARGET;
                   ROS_WARN("[TrajGenerator]: Trajectory generation failed.");
               }
               break;

           case EXEC_TRAJ:
               // 执行轨迹
               if (ros::Time::now() - traj_start_time_ < traj_duration_) {
                   // 发布位置指令
                   double t_cur = (ros::Time::now() - traj_start_time_).toSec();
                   publishPositionCommand(t_cur);
               } else {
                   exec_state_ = WAIT_TARGET;
                   ROS_INFO("[TrajGenerator]: Trajectory execution finished.");
               }
               break;

           case REPLAN_TRAJ:
               // 重新规划
               trajGeneration();
               if (traj_success_) {
                   exec_state_ = EXEC_TRAJ;
                   traj_start_time_ = ros::Time::now();
               } else {
                   exec_state_ = EMER_STOP;
               }
               break;

           case EMER_STOP:
               // 紧急停止
               publishPositionCommand(0.0);
               ROS_ERROR("[TrajGenerator]: Emergency stop!");
               break;
       }
   }
   ```

2. **trajGeneration()**
   - 调用A*搜索路径
   - 路径简化和平滑
   - 轨迹优化(最小jerk多项式)
   - 碰撞检测

   ```cpp
   void TrajectoryGeneratorNode::trajGeneration()
   {
       // 1. A*路径搜索
       Eigen::Vector3d start_pt = odom_pos_;
       Eigen::Vector3d end_pt = target_pt_;

       _astar_path_finder->AstarSearch(start_pt, end_pt);
       vector<Vector3d> path = _astar_path_finder->getPath();

       if (path.empty()) {
           ROS_WARN("A* search failed!");
           traj_success_ = false;
           return;
       }

       // 2. 路径简化
       path = _astar_path_finder->pathSimplify(path, 1.0);

       // 3. 轨迹优化
       Eigen::MatrixXd polyCoeff = _trajGene->PolyQPGeneration(
           path, VectorXd::Zero(path.size()), VectorXd::Zero(path.size()),
           VectorXd::Ones(path.size()) * (end_pt - start_pt).norm() / 10.0);

       // 4. 碰撞检测
       int unsafe_segment = _astar_path_finder->safeCheck(polyCoeff, time_allocation_);
       if (unsafe_segment != -1) {
           ROS_WARN("Trajectory collision detected at segment %d!", unsafe_segment);
           traj_success_ = false;
           return;
       }

       traj_success_ = true;
   }
   ```

3. **publishPositionCommand(double t_cur)**
   - 按时间发布位置指令
   - 计算期望位置、速度、加速度

   ```cpp
   void TrajectoryGeneratorNode::publishPositionCommand(double t_cur)
   {
       // 计算期望位置、速度、加速度
       Eigen::Vector3d pos = _trajGene->getPosPoly(polyCoeff_, seg_idx_, t_cur);
       Eigen::Vector3d vel = _trajGene->getVelPoly(polyCoeff_, seg_idx_, t_cur);
       Eigen::Vector3d acc = _trajGene->getAccPoly(polyCoeff_, seg_idx_, t_cur);

       // 发布位置指令
       quadrotor_msgs::PositionCommand cmd;
       cmd.header.stamp = ros::Time::now();
       cmd.header.frame_id = "world";
       cmd.position.x = pos(0);
       cmd.position.y = pos(1);
       cmd.position.z = pos(2);
       cmd.velocity.x = vel(0);
       cmd.velocity.y = vel(1);
       cmd.velocity.z = vel(2);
       cmd.acceleration.x = acc(0);
       cmd.acceleration.y = acc(1);
       cmd.acceleration.z = acc(2);
       cmd.yaw = 0.0;
       cmd.yaw_dot = 0.0;

       pos_cmd_pub_.publish(cmd);

       // 保存控制数据
       saveControlData(pos, odom_pos_);
   }
   ```

4. **rcvPointCloudCallBack()**
   - 接收点云地图
   - 设置障碍物到A*搜索器

5. **rcvWaypointsCallBack()**
   - 接收目标点
   - 设置目标点

**发布话题**:
- `/position_cmd`: 位置指令
- `/trajectory_generator_node/trajectory`: 多项式轨迹(用于可视化)

**订阅话题**:
- `/local_pointcloud`: 局部点云地图
- `/odometry`: 里程计
- `/goal`: 目标点

---

#### 文件: Astar_searcher.cpp
**文件路径**: `code/src/trajectory_generator/src/Astar_searcher.cpp`

**主要功能**: 3D A*路径搜索算法,**任务二补全位置**。

**关键类**: `Astarpath`

**关键参数**:
```cpp
static constexpr double kWAstarW = 1.05;        // Weighted A*权重
static constexpr double kTieBreaker = 1.0 + 1e-4;  // Tie-breaker
static constexpr double kZMovePenalty = 1.20;   // Z方向移动惩罚
static constexpr double kMinGoalZUp = 1e-3;     // 最小目标高度
static constexpr double kInflationBaseM = 0.30; // 障碍物膨胀半径
static constexpr double kMinClearanceM = 0.45;  // 最小安全距离
```

**主要函数**:

1. **getHeu()**
   - **任务二STEP 1.1**: 启发式函数
   - 使用3D对角距离启发式

   ```cpp
   double Astarpath::getHeu(MappingNodePtr node1, MappingNodePtr node2)
   {
       int dx = std::abs(node1->index(0) - node2->index(0));
       int dy = std::abs(node1->index(1) - node2->index(1));
       int dz = std::abs(node1->index(2) - node2->index(2));

       // 3D对角距离
       int d1 = std::min(dx, std::min(dy, dz));  // 对角移动次数
       int d3 = std::max(dx, std::max(dy, dz));  // 最大方向移动次数
       int d2 = dx + dy + dz - d1 - d3;          // 面对角移动次数

       const double D  = 1.0;         // 直线代价
       const double D2 = std::sqrt(2.0);  // 面对角代价
       const double D3 = std::sqrt(3.0);  // 空间对角代价

       double heu = (double)d1 * D3 + (double)(d2 - d1) * D2 + (double)(d3 - d2) * D;
       return kTieBreaker * heu;  // 应用tie-breaker
   }
   ```

2. **AstarSearch()**
   - **任务二STEP 1.2**: A*算法主循环
   - Weighted A*搜索

   ```cpp
   bool Astarpath::AstarSearch(Vector3d start_pt, Vector3d end_pt)
   {
       // 1. 初始化
       resetUsedGrids();
       Openset.clear();

       Vector3i start_idx = coord2gridIndex(start_pt);
       Vector3i end_idx = coord2gridIndex(end_pt);

       MappingNodePtr startPtr = Map_Node[start_idx(0)][start_idx(1)][start_idx(2)];
       MappingNodePtr endPtr = Map_Node[end_idx(0)][end_idx(1)][end_idx(2)];

       startPtr->g_score = 0.0;
       startPtr->f_score = startPtr->g_score + kWAstarW * getHeu(startPtr, endPtr);
       startPtr->id = 1;  // 在开放集
       Openset.insert(make_pair(startPtr->f_score, startPtr));

       // 2. 主循环
       vector<MappingNodePtr> neighborPtrSets;
       vector<double> edgeCostSets;

       while (!Openset.empty()) {
           // STEP 2.1: 弹出f_score最小的节点
           auto it = Openset.begin();
           MappingNodePtr currentPtr = it->second;
           Openset.erase(it);

           if (currentPtr->id == -1) continue;  // 已访问

           // STEP 2.2: 判断是否是终点
           if (currentPtr->index == goalIdx) {
               terminatePtr = currentPtr;
               return true;
           }

           currentPtr->id = -1;  // 标记为已访问

           // STEP 2.3: 拓展当前节点
           AstarGetSucc(currentPtr, neighborPtrSets, edgeCostSets);

           for (unsigned int i = 0; i < neighborPtrSets.size(); i++) {
               MappingNodePtr neighborPtr = neighborPtrSets[i];

               if (neighborPtr->id == -1) continue;  // 已访问
               if (isOccupied(neighborPtr->index)) continue;  // 障碍物

               double tentative_g_score = currentPtr->g_score + edgeCostSets[i];

               // STEP 2.4: 更新节点
               if (neighborPtr->id == 0) {  // 未访问
                   neighborPtr->Father = currentPtr;
                   neighborPtr->g_score = tentative_g_score;
                   neighborPtr->f_score = tentative_g_score + kWAstarW * getHeu(neighborPtr, endPtr);
                   neighborPtr->id = 1;
                   Openset.insert(make_pair(neighborPtr->f_score, neighborPtr));
               } else if (neighborPtr->id == 1) {  // 在开放集
                   if (tentative_g_score < neighborPtr->g_score) {
                       neighborPtr->Father = currentPtr;
                       neighborPtr->g_score = tentative_g_score;
                       neighborPtr->f_score = tentative_g_score + kWAstarW * getHeu(neighborPtr, endPtr);
                       Openset.insert(make_pair(neighborPtr->f_score, neighborPtr));
                   }
               }
           }
       }

       return false;  // 搜索失败
   }
   ```

3. **getPath()**
   - **任务二STEP 1.3**: 返回A*寻找到的路径
   - 反向遍历父节点

   ```cpp
   vector<Vector3d> Astarpath::getPath()
   {
       vector<Vector3d> path;
       if (terminatePtr == NULL) return path;

       // 反向遍历父节点
       vector<MappingNodePtr> front_path;
       MappingNodePtr cur = terminatePtr;
       while (cur != NULL) {
           cur->coord = gridIndex2coord(cur->index);
           front_path.push_back(cur);
           cur = cur->Father;
       }

       // 反转路径
       path.reserve(front_path.size());
       for (int i = (int)front_path.size() - 1; i >= 0; --i)
           path.push_back(front_path[i]->coord);

       return path;
   }
   ```

4. **pathSimplify()**
   - 路径后处理
   - LoS剪枝(Line-of-Sight)
   - 圆角平滑
   - 稀疏化

   ```cpp
   vector<Vector3d> Astarpath::pathSimplify(const vector<Vector3d>& path,
                                             double path_resolution)
   {
       // 1. 去重
       std::vector<Vector3d> clean;
       clean.push_back(path.front());
       for (size_t i = 1; i < path.size(); ++i) {
           if ((path[i] - clean.back()).norm() > 1e-4)
               clean.push_back(path[i]);
       }

       // 2. LoS剪枝(贪心算法)
       std::vector<Vector3d> pruned;
       pruned.push_back(clean[0]);
       size_t i = 0;
       while (i < clean.size() - 1) {
           size_t j = clean.size() - 1;
           for (; j > i + 1; --j) {
               if (segmentValid(clean[i], clean[j]))  // 碰撞检测
                   break;
           }
           pruned.push_back(clean[j]);
           i = j;
       }

       // 3. 圆角平滑
       std::vector<Vector3d> fillet;
       fillet.push_back(pruned.front());
       for (size_t k = 1; k + 1 < pruned.size(); ++k) {
           const Vector3d A = pruned[k - 1];
           const Vector3d B = pruned[k];
           const Vector3d C = pruned[k + 1];

           // 计算转角
           const Vector3d v1 = (B - A).normalized();
           const Vector3d v2 = (C - B).normalized();
           const double cosang = v1.dot(v2);
           const double ang = std::acos(cosang);

           // 如果转角足够大,插入圆角点
           if (ang > 0.35) {  // 约20度
               const double d = std::min(0.60, 0.30 * std::min((B-A).norm(), (C-B).norm()));
               const Vector3d B1 = B - v1 * d;
               const Vector3d B2 = B + v2 * d;

               if (segmentValid(A, B1) && segmentValid(B1, B2) && segmentValid(B2, C)) {
                   fillet.push_back(B1);
                   fillet.push_back(B2);
               } else {
                   fillet.push_back(B);
               }
           } else {
               fillet.push_back(B);
           }
       }
       fillet.push_back(pruned.back());

       // 4. 稀疏化(根据安全距离自适应)
       std::vector<Vector3d> out;
       out.push_back(fillet.front());
       for (size_t s = 0; s + 1 < fillet.size(); ++s) {
           const Vector3d a = fillet[s];
           const Vector3d b = fillet[s + 1];
           const double L = (b - a).norm();

           // 根据最小安全距离确定最大段长
           const double minc = segmentMinClearance(a, b);
           double max_len = 2.0;
           if (minc >= 2.0) max_len = 4.0;
           else if (minc >= 1.0) max_len = 2.0;
           else max_len = 1.0;

           // 分段
           const int N = std::max(1, (int)std::ceil(L / max_len));
           for (int k = 1; k <= N; ++k) {
               const double t = (double)k / (double)N;
               Vector3d p = a + t * (b - a);
               out.push_back(p);
           }
       }

       return out;
   }
   ```

5. **AstarGetSucc()**
   - 26邻域后继生成
   - 禁止切角

6. **set_barrier()**
   - 设置障碍物
   - 障碍物膨胀

7. **safeCheck()**
   - 轨迹碰撞检测
   - 沿轨迹采样检测

---

#### 文件: trajectory_generator_waypoint.cpp
**文件路径**: `code/src/trajectory_generator/src/trajectory_generator_waypoint.cpp`

**主要功能**: 最小jerk多项式轨迹优化器。

**关键类**: `TrajectoryGeneratorWaypoint`

**主要函数**:

1. **PolyQPGeneration()**
   - 生成最小jerk分段多项式轨迹
   - 使用LU分解求解QP问题

   ```cpp
   Eigen::MatrixXd TrajectoryGeneratorWaypoint::PolyQPGeneration(
       const int d_order, const Eigen::MatrixXd& Path,
       const Eigen::MatrixXd& Vel, const Eigen::MatrixXd& Acc,
       const Eigen::VectorXd& Time)
   {
       // 1. 构建约束矩阵M
       Eigen::MatrixXd M = Eigen::MatrixXd::Zero(K * d_order, K * d_order);

       // F0: 初始位置/速度/加速度约束
       M.block(0, 0, 3, d_order) = getF(d_order, 0, 0);
       M.block(3, (K-1)*d_order, 3, d_order) = getF(d_order, 0, 1);

       // Ei/Fi: 分段连续性约束
       for (int i = 0; i < K - 1; i++) {
           M.block(3 * (i + 1), i * d_order, 3, d_order) = getF(d_order, Time(i), 0);
           M.block(3 * (i + 1), (i + 1) * d_order, 3, d_order) = -getF(d_order, 0, 1);
       }

       // EM: 终端位置/速度/加速度约束
       M.block(3 * (K - 1), 0, 3, d_order) = getF(d_order, Time(K-1), 0);
       M.block(3 * K - 3, (K-1)*d_order, 3, d_order) = getF(d_order, 0, 1);

       // 2. 构建右端项b
       Eigen::MatrixXd b = Eigen::MatrixXd::Zero(K * d_order, 3);
       b.block(0, 0, 3, 3) = Path.row(0);
       b.block(3 * (K - 1), 0, 3, 3) = Path.row(K - 1);

       for (int i = 0; i < K - 1; i++) {
           b.block(3 * (i + 1), 0, 3, 3) = Path.row(i + 1);
       }

       // 3. LU分解求解
       Eigen::MatrixXd coefficientMatrix(K * d_order, 3);
       for (int i = 0; i < 3; i++) {
           coefficientMatrix.col(i) = M.lu().solve(b.col(i));
       }

       return coefficientMatrix;
   }
   ```

2. **getPosPoly()**
   - 计算轨迹位置

3. **getVelPoly()**
   - 计算轨迹速度

4. **getAccPoly()**
   - 计算轨迹加速度

**轨迹形式**:
- 分段多项式
- 每段为5阶多项式(最小jerk)
- 位置、速度、加速度连续

---

#### 文件: include/Astar_searcher.h
**文件路径**: `code/src/trajectory_generator/include/Astar_searcher.h`

**主要功能**: A*搜索器类定义。

**关键结构体**:
```cpp
struct MappingNode {
    int id;                    // 0: 未访问, 1: 开放集, -1: 已访问
    Eigen::Vector3d coord;     // 世界坐标
    Eigen::Vector3i index;     // 栅格索引
    double g_score;            // 实际代价
    double f_score;            // 估计总代价
    MappingNodePtr Father;     // 父节点
};
```

**关键成员变量**:
```cpp
uint8_t *data;                         // 占据栅格地图
uint8_t *data_raw;                     // 原始障碍物地图
MappingNodePtr ***Map_Node;            // 3D节点数组
std::multimap<double, MappingNodePtr> Openset;  // 开放集
MappingNodePtr terminatePtr;           // 终点节点
Vector3i goalIdx;                      // 终点索引
```

**关键方法**:
```cpp
void AstarSearch(Vector3d start_pt, Vector3d end_pt);  // A*搜索
vector<Vector3d> getPath();                          // 获取路径
vector<Vector3d> pathSimplify(...);                   // 路径简化
double getHeu(MappingNodePtr node1, MappingNodePtr node2);  // 启发式函数
void set_barrier(double x, double y, double z);       // 设置障碍物
bool safeCheck(MatrixXd polyCoeff, VectorXd time);    // 碰撞检测
```

---

#### 文件: include/trajectory_generator_waypoint.h
**文件路径**: `code/src/trajectory_generator/include/trajectory_generator_waypoint.h`

**主要功能**: 轨迹生成器类定义。

**关键方法**:
```cpp
Eigen::MatrixXd PolyQPGeneration(...);  // 多项式轨迹生成
Eigen::Vector3d getPosPoly(...);        // 计算位置
Eigen::Vector3d getVelPoly(...);        // 计算速度
Eigen::Vector3d getAccPoly(...);        // 计算加速度
```

---

#### 文件: include/node.h
**文件路径**: `code/src/trajectory_generator/include/node.h`

**主要功能**: A*节点结构体定义。

**关键结构体**:
```cpp
struct MappingNode {
    int id;                    // 节点状态
    Eigen::Vector3d coord;     // 世界坐标
    Eigen::Vector3i index;     // 栅格索引
    double g_score;            // 实际代价
    double f_score;            // 估计总代价
    MappingNodePtr Father;     // 父节点
};
```

---

### 四、Utils 模块

#### 1. traj_server 包

**包路径**: `code/src/Utils/traj_server/`

**功能概述**: 轨迹服务器,接收多项式轨迹并按时间发布位置指令。

##### 文件: traj_server.cpp
**文件路径**: `code/src/Utils/traj_server/src/traj_server.cpp`

**主要功能**: 轨迹服务器节点。

**主要函数**:

1. **rcvTrajectoryCallabck()**
   - 接收多项式轨迹
   - 存储轨迹参数

2. **pubPositionCommand()**
   - 按时间发布位置指令
   - 计算期望位置、速度、加速度

**注意**: 本项目中`trajectory_generator_node`已直接发布位置指令,`traj_server`作为备用/可视化用途。

---

#### 2. odom_visualization 包

**包路径**: `code/src/Utils/odom_visualization/`

**功能概述**: 里程计可视化,显示无人机模型、轨迹、速度/加速度箭头。

##### 文件: odom_visualization.cpp
**文件路径**: `code/src/Utils/odom_visualization/src/odom_visualization.cpp`

**主要功能**: 里程计可视化节点。

**主要函数**:

1. **odom_callback()**
   - 接收里程计数据
   - 更新可视化

2. **cmd_callback()**
   - 接收控制指令
   - 显示期望轨迹

**发布话题**:
- `/robot`: 无人机网格模型
- `/pose`: 当前位姿
- `/path`: 历史轨迹
- `/velocity`: 速度箭头
- `/acceleration`: 加速度箭头

**订阅话题**:
- `/odometry`: 里程计
- `/position_cmd`: 位置指令

---

#### 3. quadrotor_msgs 包

**包路径**: `code/src/Utils/quadrotor_msgs/`

**功能概述**: 四旋翼ROS消息定义。

##### 文件: encode_msgs.cpp
**文件路径**: `code/src/Utils/quadrotor_msgs/src/encode_msgs.cpp`

**主要功能**: 将ROS消息编码为二进制数据(用于串口通信)。

**关键函数**:
```cpp
void encodeSO3Command(const quadrotor_msgs::SO3Command& cmd, std::vector<uint8_t>& output);
void encodeTRPYCommand(const quadrotor_msgs::TRPYCommand& cmd, std::vector<uint8_t>& output);
```

---

##### 文件: decode_msgs.cpp
**文件路径**: `code/src/Utils/quadrotor_msgs/src/decode_msgs.cpp`

**主要功能**: 将二进制数据解码为ROS消息。

**关键函数**:
```cpp
void decodeOutputData(const std::vector<uint8_t>& input, quadrotor_msgs::OutputData& output);
void decodeStatusData(const std::vector<uint8_t>& input, quadrotor_msgs::StatusData& status);
```

---

##### 消息定义文件:

**msg/PositionCommand.msg**:
```
std_msgs/Header header
geometry_msgs/Vector3 position
geometry_msgs/Vector3 velocity
geometry_msgs/Vector3 acceleration
float64 yaw
float64 yaw_dot
float64 kx[3]
float64 kv[3]
```

**msg/SO3Command.msg**:
```
std_msgs/Header header
geometry_msgs/Vector3 force
geometry_msgs/Quaternion orientation
float64 kR[3]
float64 kOm[3]
float64 corrections[3]
bool enable_motors
bool use_external_yaw
```

---

## documents 目录详解

### 一、homework.pdf
**文件路径**: `documents/homework.pdf`

**功能概述**: 作业题目PDF,包含三个题目。

**题目1: 坐标系转换**
- **问题背景**: 无人机搭载机械臂,需要计算机体坐标系到执行器坐标系的转换
- **已知条件**:
  - 无人机姿态: `tracking.csv` (四元数)
  - 执行器相对机体姿态: 圆锥运动
  - 参数: `ω = 0.5`, `α = π/12`
- **任务**: 计算执行器在世界坐标系下的姿态(四元数)
- **提交方式**:
  - 绘制四元数变化曲线
  - 将计算思路和曲线放入报告

**题目2: 开放题(规划/控制/动力学)**
1. **A*轨迹规划的启发式与路径简化**
   - 解释tie-breaker对开集拓展顺序和路径平滑性的影响
   - 如何修改启发或边权以偏好平面飞行
   - 讨论path_resolution对跟踪误差和安全性的影响

2. **SO(3)位置控制器的力姿态生成**
   - 说明各项在飞行中的作用
   - 解释为何需要对ka做截断或限幅
   - 讨论质量参数调整对推力、姿态、稳定性的影响

3. **动力学建模与约束**
   - 说明质量、惯量、气动阻尼建模的影响
   - 讨论参数估计误差的可观测现象
   - 加入气动阻力的调整方案

**题目3: 无人机微分平坦性(Optional)**
- **问题背景**: 利用微分平坦性计算无人机姿态
- **已知条件**:
  - 轨迹: 双纽线 `x = A * cos(ωt), y = A * sin(2ωt) / 2`
  - 偏航角: 与速度方向对齐
  - 参数: `A = 5`, `ω = 1`, `t ∈ [0, 2π]`
- **任务**:
  1. 推导姿态计算过程
  2. 编写ROS包`quadrotor_df`实现
  3. 输出`df_quaternion.csv`
- **提交方式**:
  - 计算思路和四元数变化图放入报告
  - `quadrotor_df`包放在`code/src`下
  - `df_quaternion.csv`放在`solutions`下

---

### 二、tracking.csv
**文件路径**: `documents/tracking.csv`

**功能概述**: 题目1的无人机姿态跟踪数据。

**文件格式**:
```csv
t,qx,qy,qz,qw
0.0,-0.02449607662856579,-0.20002004504203796,0.062320686876773834,-0.9775010347366333
0.02,-0.026297910138964653,-0.20573893189430237,0.06302984058856964,-0.9762208461761475
...
```

**数据说明**:
- `t`: 时间(秒)
- `qx, qy, qz, qw`: 四元数(x,y,z,w)
- 共862行数据

---

### 三、solutions/q1_coordinate_transform.py
**文件路径**: `documents/solutions/q1_coordinate_transform.py`

**功能概述**: 题目1的坐标系转换解答代码。

**主要功能**:

1. **四元数归一化**:
   ```python
   def quat_normalize(q):
       n = np.linalg.norm(q, axis=-1, keepdims=True)
       n = np.maximum(n, EPS)
       return q / n
   ```

2. **四元数转旋转矩阵**:
   ```python
   def quat_xyzw_to_rot(q):
       x, y, z, w = q[..., 0], q[..., 1], q[..., 2], q[..., 3]
       # 构造旋转矩阵
       R[..., 0, 0] = 1 - 2 * (y*y + z*z)
       R[..., 0, 1] = 2 * (x*y - w*z)
       # ...
       return R
   ```

3. **旋转矩阵转四元数**:
   ```python
   def rot_to_quat_xyzw(R):
       # 使用trace和优势对角元素
       tr = R[:, 0, 0] + R[:, 1, 1] + R[:, 2, 2]
       if tr > 0.0:
           S = sqrt(tr + 1.0) * 2.0
           qw = 0.25 * S
           qx = (R[:, 2, 1] - R[:, 1, 2]) / S
           # ...
       else:
           # 根据优势对角元素选择分支
           idx = argmax([R00, R11, R22])
           # ...
       return quat_normalize(q)
   ```

4. **计算R_BD**:
   ```python
   def compute_R_BD(t, omega, alpha):
       ct = np.cos(omega * t)
       st = np.sin(omega * t)
       ca = math.cos(alpha)
       sa = math.sin(alpha)

       R = np.zeros((t.shape[0], 3, 3))
       R[:, 0, 0] = ct
       R[:, 0, 1] = -st * ca
       R[:, 0, 2] = st * sa
       # ...
       return R
   ```

5. **主计算流程**:
   ```python
   # 1. 读取tracking.csv
   df = pd.read_csv("tracking.csv")
   t = df["t"].to_numpy()
   q_track = df[["qx", "qy", "qz", "qw"]].to_numpy()

   # 2. 归一化输入四元数
   q_track = quat_normalize(q_track)

   # 3. 四元数转旋转矩阵 R_WB
   RWB = quat_xyzw_to_rot(q_track)

   # 4. 计算 R_BD
   RBD = compute_R_BD(t, omega, alpha)

   # 5. 计算 R_WD = R_WB @ R_BD
   RWD = RWB @ RBD

   # 6. 旋转矩阵转四元数
   qWD = rot_to_quat_xyzw(RWD)

   # 7. 强制qw >= 0
   qWD = enforce_qw_ge0(qWD)

   # 8. 强制时间连续性
   qWD = enforce_time_continuity_by_dot(qWD)

   # 9. 再次归一化
   qWD = quat_normalize(qWD)
   ```

6. **输出结果**:
   - 保存CSV: `solutions/q1_quaternion_world.csv`
   - 绘制曲线: `solutions/q1_quaternion_world.png`

---

### 四、solutions/q1_quaternion_world.csv
**文件路径**: `documents/solutions/q1_quaternion_world.csv`

**功能概述**: 题目1的计算结果CSV文件。

**文件格式**:
```csv
t,qx,qy,qz,qw
0.00,0.0499792,0,0,0.9987503
0.02,0.0499167,0.0499167,0.0024979,0.9975021
0.04,0.0523491,0.0473595,0.0523491,0.9961306
...
```

**数据说明**:
- `t`: 时间(秒,保留2位小数)
- `qx, qy, qz, qw`: 四元数(保留7位小数)
- 归一化且qw >= 0

---

### 五、solutions/q1_quaternion_world.png
**文件路径**: `documents/solutions/q1_quaternion_world.png`

**功能概述**: 题目1的四元数变化曲线图。

**图表说明**:
- X轴: 时间 t [s]
- Y轴: 四元数分量
- 四条曲线: qx, qy, qz, qw
- 包含网格和图例

---

## solutions 目录详解

### 一、result.txt
**文件路径**: `solutions/result.txt`

**功能概述**: 任务三运行结果文件。

**文件内容**:
```
0.07516997195426592 150.62267017364502 30.378813075265477 0 51.234291040635284
```

**数据说明**:
- 第1列: RMSE (均方根误差) = 0.07517
- 第2列: Total Time (轨迹运行总时间) = 150.62秒
- 第3列: Total Length (轨迹总长度) = 30.38米
- 第4列: Collision (是否碰撞) = 0 (无碰撞)
- 第5列: Overall Score (综合得分) = 51.23

**生成方式**:
```bash
python3 calculate_results.py
```

---

## 项目架构总结

### 一、系统架构图

```
┌─────────────────────────────────────────────────────────────┐
│                     用户输入                                 │
│                   (RViz 3D Nav Goal)                        │
└────────────────────────────┬────────────────────────────────┘
                             │
                             ▼
┌─────────────────────────────────────────────────────────────┐
│              trajectory_generator_node                       │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │ A*搜索       │→ │ 路径简化     │→ │ 轨迹优化     │      │
│  │ (前端规划)   │  │ (后处理)     │  │ (多项式)     │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
│         ↓                  ↓                  ↓              │
│  Astar_searcher.cpp  pathSimplify()  PolyQPGeneration()      │
└────────────────────────────┬────────────────────────────────┘
                             │
                             ▼
┌─────────────────────────────────────────────────────────────┐
│                    so3_control                              │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │ 位置误差     │  │ 速度误差     │  │ 重力补偿     │      │
│  │ PD控制       │  │ PD控制       │  │              │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
│         ↓                  ↓                  ↓              │
│  计算期望推力和姿态 (SO3Control.cpp)                           │
└────────────────────────────┬────────────────────────────────┘
                             │
                             ▼
┌─────────────────────────────────────────────────────────────┐
│            quadrotor_simulator_so3                           │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │ 姿态控制     │  │ 动力学仿真   │  │ 电机分配     │      │
│  │ (SO3李代数)  │  │ (刚体动力学) │  │ (混控矩阵)   │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
│         ↓                  ↓                  ↓              │
│  getControl()        operator()()        电机转速            │
└────────────────────────────┬────────────────────────────────┘
                             │
                             ▼
┌─────────────────────────────────────────────────────────────┐
│                    仿真输出                                   │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │ /odometry    │  │ /sim/imu     │  │ 可视化       │      │
│  │ (里程计)     │  │ (IMU数据)    │  │ (RViz)       │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
└─────────────────────────────────────────────────────────────┘
```

### 二、信息流图

```
地图生成:
random_complex_generator → /random_complex/global_map
random_complex_generator → /random_complex/global_ground

地图渲染:
/global_map → pcl_render_node → /local_pointcloud
/global_ground → pcl_render_node → /global_ground_vis

里程计:
quadrotor_simulator_so3 → /odometry → trajectory_generator_node
quadrotor_simulator_so3 → /odometry → so3_control
quadrotor_simulator_so3 → /odometry → odom_visualization

目标点:
RViz → /goal → trajectory_generator_node

轨迹生成:
trajectory_generator_node → /position_cmd → so3_control
trajectory_generator_node → /trajectory_generator_node/trajectory → 可视化

控制:
so3_control → /so3_cmd → quadrotor_simulator_so3

可视化:
odom_visualization → /robot, /pose, /path, /velocity, /acceleration → RViz
```

### 三、关键技术点

1. **A*路径搜索**:
   - 3D栅格地图
   - 26邻域扩展
   - Weighted A* (w=1.05)
   - 3D对角距离启发式
   - Tie-breaker减少"走之"路径

2. **路径简化**:
   - LoS剪枝(贪心算法)
   - 圆角平滑
   - 自适应稀疏化(根据安全距离)

3. **轨迹优化**:
   - 最小jerk多项式
   - 分段5阶多项式
   - LU分解求解QP问题
   - 位置、速度、加速度连续

4. **SO3位置控制**:
   - PD控制 + 重力补偿
   - 根据期望推力构造姿态
   - 姿态环在仿真器中实现

5. **SO3姿态控制**:
   - SO3李代数姿态误差
   - PD控制 + 科里奥利补偿
   - 四电机混控分配

6. **刚体动力学**:
   - 平动: F = ma (重力 + 推力 + 阻力)
   - 转动: τ = J·ω̇ + ω×(J·ω) (欧拉方程)
   - 空气阻力: -k·v

### 四、评分指标

1. **代码补全** (30分):
   - 任务一: 四旋翼动力学模型
   - 任务二: A*算法补全

2. **控制效果** (1-40分):
   - RMSE (均方根误差)
   - 轨迹运行时间
   - 轨迹总长度
   - 碰撞状态
   - 综合得分 = 200*RMSE + 0.2*time + 0.2*length + 40*collision

3. **文档作业** (30分):
   - 题目1: 坐标系转换
   - 题目2: 开放题(规划/控制/动力学)

4. **附加题** (1-10分):
   - 任务四: 改进(前端/后端/控制器)

---

## 附录

### 一、编译和运行

#### 1. 编译代码
```bash
cd MRPC-2025-homework/code
catkin_make
```

#### 2. 测试悬停(任务一)
```bash
cd MRPC-2025-homework/code
source devel/setup.bash
roslaunch trajectory_generator test_control.launch
```

#### 3. 测试路径规划(任务二)
```bash
cd MRPC-2025-homework/code
source devel/setup.bash
roslaunch trajectory_generator demo.launch
```

#### 4. 运行评估(任务三)
```bash
cd MRPC-2025-homework/
python3 calculate_results.py
```

#### 5. 检查提交完整性
```bash
cd MRPC-2025-homework/
bash check_completeness.sh
```

### 二、关键参数

#### 1. A*搜索参数
```cpp
kWAstarW = 1.05              // Weighted A*权重
kTieBreaker = 1.0 + 1e-4    // Tie-breaker
kZMovePenalty = 1.20         // Z方向移动惩罚
kInflationBaseM = 0.30       // 障碍物膨胀半径
kMinClearanceM = 0.45        // 最小安全距离
```

#### 2. 控制器参数(任务三调参)
```cpp
// 位置环PD增益
kx_ = Eigen::Vector3d(15.7, 8.7, 6.0);  // 位置增益
kv_ = Eigen::Vector3d(6.4, 13.4, 4.0);   // 速度增益

// 姿态环PD增益
kR = Eigen::Vector3d(3.0, 3.0, 3.0);     // 姿态增益
kOmega = Eigen::Vector3d(0.5, 0.5, 0.5); // 角速度增益
```

#### 3. 无人机参数
```cpp
mass = 0.98 kg                    // 质量
g = 9.81 m/s^2                    // 重力加速度
Ixx = Iyy = 2.64e-3 kg·m^2        // 惯性矩
Izz = 4.96e-3 kg·m^2
kf = 8.98132e-9                   // 推力系数
km = 0.07 * 3 * prop_radius * kf  // 力矩系数
arm_length = 0.26 m               // 臂长
prop_radius = 0.062 m             // 螺旋桨半径
```

### 三、常见问题

1. **编译失败**:
   - 检查ROS环境是否正确source
   - 删除build和devel目录重新编译
   - 检查依赖包是否安装

2. **A*搜索失败**:
   - 检查起点和终点是否在障碍物内
   - 检查地图是否正确加载
   - 检查膨胀半径是否过大

3. **轨迹跟踪效果差**:
   - 调整`kx_`和`kv_`参数
   - 检查轨迹是否过于激进
   - 检查碰撞检测是否过于严格

4. **碰撞检测误报**:
   - 调整`kMinClearanceM`参数
   - 检查障碍物膨胀是否合理
   - 检查轨迹采样密度

---

## 总结

本项目是一个完整的四旋翼无人机规划与控制系统,涵盖了从地图生成、路径规划、轨迹优化到动力学仿真的全流程。项目结构清晰,代码规范,适合作为移动机器人规划与控制课程的教学实践。

**主要特点**:
1. 基于ROS开发,模块化设计
2. 包含完整的仿真环境
3. 提供了详细的文档和示例
4. 支持多种改进方向(前端/后端/控制器)

**学习价值**:
1. 理解四旋翼动力学模型
2. 掌握A*路径搜索算法
3. 学习轨迹优化方法
4. 熟悉SO3控制理论
5. 提升ROS开发能力

**改进方向**:
1. 前端规划: JPS3D、Hybrid A*、RRT等
2. 后端优化: 最小控制量、时间最优等
3. 控制器: MPC、自适应控制等

---

**文档版本**: 1.0
**生成日期**: 2026年1月2日
**作者**: iFlow CLI